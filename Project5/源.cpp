#include<stdio.h>
#include<math.h>
#include<stdlib.h>
int point1[200][3] = { {20,20,1},{20,20,1},{20,20,1},{43,72},{43,72},{43,72},{43,72},{43,72},{43,72},{43,73},{43,74}
,{43,76},{43,79},{43,84},{43,89},{43,96},{43,103},{43,111},{43,119},{43,127},{43,135}
,{43,142},{43,148},{43,153},{43,157},{43,161},{43,164},{43,166},{43,168},{43,169},{43,170}
,{43,171},{43,172},{43,173},{43,174},{43,174},{43,174},{43,174},{44,175},{45,175},{46,175}
,{48,175},{50,176},{52,177},{54,178,1},{56,178,1},{58,178,1},{60,178},{62,178},{64,178},{66,178}
,{68,178},{70,178},{72,178},{73,178},{74,178},{75,178},{76,178},{77,178},{78,178},{79,178}
,{80,178},{80,178},{81,178},{82,179},{83,180},{84,181},{84,182},{84,183},{84,185},{84,187}
,{84,189},{84,192},{84,195},{84,198},{84,201},{84,204},{84,207},{84,210},{84,213},{84,216}
,{84,218},{84,220},{84,222},{84,224},{85,226},{86,227},{87,228},{89,229},{91,230},{94,231}
,{98,232},{102,233},{106,234},{111,235},{116,235},{122,235},{128,235},{134,235},{140,235},{146,235}
,{152,235},{158,235},{163,235},{168,235},{172,235},{176,235},{180,235},{183,235},{186,235},{188,235}
,{190,235},{192,235},{192,235} };

int point2[200][3] = { {119,36},{119,36},{119,36},{119,36},{119,36},{119,36},{119,36},{119,37},{119,38},{119,39},{119,40}
,{119,42},{119,45},{119,49},{119,54},{119,61},{119,68},{119,77},{119,85},{119,93},{119,100}
,{119,106},{119,112},{119,116},{119,120},{119,123},{119,126},{119,128},{119,130},{119,131},{119,132}
,{119,133},{118,134},{117,135},{116,136},{115,137},{114,138},{113,139},{112,140},{110,142},{108,144}
,{106,146},{104,148},{102,150},{101,152},{100,154},{99,156},{98,158},{97,160},{96,162},{95,164}
,{94,165},{94,166},{94,167},{94,168},{94,169},{94,170},{95,171},{96,172},{98,173},{100,174}
,{103,175},{106,177},{109,178},{112,179},{115,180},{117,181},{119,181},{121,181},{123,181},{125,181}
,{126,181},{127,181},{128,181},{129,181},{130,181},{131,180},{132,179},{133,178},{134,176},{134,174}
,{134,171},{134,168},{134,164},{134,160},{133,155},{132,150},{131,145},{130,140},{129,136},{128,133}
,{127,130},{126,128},{125,126},{124,125},{124,125} };

int point3[200][3] = { {120,20,1},{200,20,1},{200,20,1},{143,72},{43,72},{43,72},{43,72},{43,72},{43,72},{43,73},{43,74}
,{43,76},{43,79},{43,84},{43,89},{43,96},{43,103},{43,111},{43,119},{43,127},{43,135}
,{43,142},{43,148},{43,153},{43,157},{43,161},{43,164},{43,166},{43,168},{43,169},{43,170}
,{43,171},{43,172},{43,173},{43,174},{43,174},{43,174},{43,174},{44,175},{45,175},{46,175}
,{48,175},{50,176},{52,177},{54,178,1},{56,178,1},{58,178,1},{60,178},{62,178},{64,178},{66,178}
,{68,178},{70,178},{72,178},{73,178},{74,178},{75,178},{76,178},{77,178},{78,178},{79,178}
,{80,178},{80,178},{81,178},{82,179},{83,180},{84,181},{84,182},{84,183},{84,185},{84,187}
,{84,189},{84,192},{84,195},{84,198},{84,201},{84,204},{84,207},{84,210},{84,213},{84,216}
,{84,218},{84,220},{84,222},{84,224},{85,226},{86,227},{87,228},{89,229},{91,230},{94,231}
,{98,232},{102,233},{106,234},{111,235},{116,235},{122,235},{128,235},{134,235},{140,235},{146,235}
,{152,235},{158,235},{163,235},{168,235},{172,235},{176,235},{180,235},{183,235},{186,235},{188,235}
,{190,235},{192,235},{192,235}};
double pointin[200][2] = { {70,92},{70,92},{70,92},{70,92},{71,92},{73,92},{76,91},{80,90},{85,89},
    {91,88},{97,87},{104,86},{109,86},{116,86},{123,86},{131,86},{139,87},{146,88},{153,89},{160,90},
    {167,92},{173,94},{178,96},{183,98},{187,101},{190,105},{193,110},{195,117},{197,125},{198,134},{199,144},
    {199,154},{199,164},{198,174},{197,184},{195,194},{193,203},{189,211},{186,218},{183,223},{180,227},{177,230},
    {173,233},{169,235},{165,237},{161,239},{157,240},{152,241},{147,242},{141,243},{135,244},{129,244},{123,244},
    {117,244},{111,244},{104,244},{97,243},{90,242},{83,241},{77,240},{72,239},{67,238},{63,237},{59,236},{56,235},
    {53,234},{51,233},{49,231},{48,228},{47,224},{47,219},{47,212},{47,203},{47,192},{48,180},{49,167},{50,155},{51,142},
    {52,130},{53,119},{53,108},{54,96},{54,85},{54,76},{55,68},{56,62},{56,58},{56,55},{56,54},{56,54} };
double pointout[200][3] = {};
int point4[200][3] ={ {46,177,1},{48,179,2},{51,181,3},{54,183,4},{58,184,5},{62,186,6},{66,187,7},{70,189,8},{74,191,9},{78,192,10} };
int point5[10][3] ={ {53,187,1},{53,187,2},{54,187,3},{55,188,4},{56,189,5},{58,190,6},{60,191,7},{62,192,8},{64,193,9},{66,194,10} };
//point1主保存 point3验证输入保存
int data_x, data_y, count2 = 0;
int d = 0;//两点间的距离
int aver = 0;
//算法部分，调用后会将全局变量aver变为两条空间线相差距离
void trans() {
    double k = 1.2;
    for (int i = 0; i < 200; i++) {

        pointout[i][0] = pointin[i][0];
        pointout[i][1] = pointin[i][1];
        pointout[i][0] = i * k;
    }

}
int min(int a, int b, int c) {
    int min = 0;
    if ((a >= b && b >= c) || (b >= a && a >= c)) { min = c; }
    if ((a >= c && c >= b) || (c >= a && a >= b)) { min = b; }
    if ((b >= c && c >= a) || (c >= b && b >= a)) { min = a; }
    return min;
}
int max(int a, int b, int c) {
    int max = 0;
    if ((a <= b && b <= c) || (b <= a && a <= c)) { max = c; }
    if ((a <= c && c <= b) || (c <= a && a <= b)) { max = b; }
    if ((b <= c && c <= a) || (c <= b && b <= a)) { max = a; }
    return max;
}
void vabluematrix(int a[200][3], int b[200][3]) {//将b中的数据复制给数组a
    for (int i = 0; i < 200; i++) {
        a[i][0] = b[i][0];
        a[i][1] = b[i][1];
        a[i][2] = b[i][2];
    }
}



//两线相差平均距离
int password[200][3] = { 0 };//用户密码
int userinput[200][3] = { 0 };//外界输入
int** matrix = NULL; //dtw矩阵
int** path = NULL;//路径坐标矩阵
int dist2(int a[3], int b[3]) {//计算两坐标空间距离
    double c = sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2]));
    return int(c);
}
int dist(int x1, int y1, int z1, int x2, int y2, int z2) //计算任意两空间点的距离
{
    d = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));
    return d;
}
int compute(int ef[200][3]) {//计算ab的实际坐标个数（数组实际长度）
    int lenth = 0;//password实际长度
    for (int i = 0; i < 200; i++) {
        if (ef[i][0] != 0) {
            lenth++;
        }
    }
    return lenth;
}
int** creatmatrix(int ab[200][3], int cd[200][3]) {//累积距离矩阵生成，最后装入一个n*m的矩阵matrix
    int lenp = compute(ab);//password实际长度
    int lenu = compute(cd);//userinput实际长度

    int** matrix = { 0 }; //用二级指针动态申请二维数组
    matrix = (int**)malloc(sizeof(int*) * lenp);
    for (int i = 0; i < lenp; i++) {
        matrix[i] = (int*)malloc(sizeof(int) * lenu);
    }
    //计算左下角
    matrix[0][0] = dist(ab[0][0], ab[0][1], ab[0][2], cd[0][0], cd[0][1], cd[0][2]);
    
    //计算左边一列
    for (int i = 1; i < lenp; i++) {
        matrix[i][0] = matrix[i - 1][0] + dist(ab[0][0], ab[0][1], ab[0][2], cd[i][0], cd[i][1], cd[i][2]);
    }
    //底下一行
    for (int i = 1; i < lenu; i++) {
        matrix[0][i] = matrix[0][i - 1] + dist(ab[i][0], ab[i][1], ab[i][2], cd[0][0], cd[0][1], cd[0][2]);
    }
    //中间部分
    for (int i = 1; i < lenp; i++) {
        for (int j = 1; j < lenu; j++) {
            matrix[i][j] = min(matrix[i - 1][j - 1], matrix[i][j - 1], matrix[i - 1][j]) + dist(ab[i][0], ab[i][1], ab[i][2], cd[j][0], cd[j][1], cd[j][2]);
        }
    }
    int e = lenu;
    int f = lenp;
    for (int i = 0; i < lenp; i++) {
        for (int j = 0; j < lenu; j++) {
            printf("(%d),", matrix[i][j]);
        }
        printf("\n");
    }
    return matrix;
}
int findpath(int** matrix, int ab[200][3], int cd[200][3]) {//找到最短距离对点路径
    int sum = 0;//两线总距离
    aver = 0;
    int lenp = compute(ab);//password实际长度
    int lenu = compute(cd);//userinput实际长度
    int i = lenp - 1; //从后往前回溯，尾下标为实际长度减1
    int j = lenu - 1;
    int count = 0;//最终有count个配对点
    int d[200] = { 0 };//每对点的距离存入该数组，从后往前存
    int n = (lenp > lenu) ? lenp : lenu;//路径最终实际大小
    int** path = { 0 }; //用二级指针动态申请二维数组
    path = (int**)malloc(sizeof(int*) * (n + 2));
    for (int i = 0; i < (n + 2); i++) {
        path[i] = (int*)malloc(sizeof(int) * 2);
    }//整个路径的坐标存入该数组，从矩阵最后往前回溯
    while (true)
    {

        if (i < 0 || j < 0) {
            break;
        }if (i < n && j < n) {
            if (i > 0 && j > 0) {//中间部分找路径
                path[0][0] = i;
                path[0][1] = j;
                int k = min(matrix[i - 1][j - 1], matrix[i][j - 1], matrix[i - 1][j]);
                if (k == matrix[i - 1][j - 1]) {
                    d[count] = matrix[i][j] - matrix[i - 1][j - 1];
                    i = i - 1;
                    j = j - 1;
                    count++;
                }
                else if (k == matrix[i][j - 1]) {//
                    d[count] = matrix[i][j] - matrix[i][j - 1];
                    i = i;
                    j = j - 1;
                    count++;

                }
                else if (k == matrix[i - 1][j]) {//

                    d[count] = matrix[i][j] - matrix[i - 1][j];
                    i = i - 1;
                    j = j;
                    count++;
                }
            }
            else if (i == 0 && j == 0) {//最后一对点1距离和路径坐标
                d[count] = matrix[i][j];
                path[count][0] = i;
                path[count][1] = j;
                break;//回溯到最后一个点，退出
            }
            else if (i == 0 && j != 0) {//部分若路径靠近最左一列
                d[count] = matrix[i][j] - matrix[i][j - 1];
                path[count][0] = 0;
                path[count][1] = j;
                j = j - 1;
                count++;
            }
            else if (j == 0 && i != 0) {//若部分路径为最下一排
                d[count] = matrix[i][j] - matrix[i - 1][j];
                path[count][0] = i;
                path[count][1] = 0;
                i = i - 1;
                count++;
            }
        }
    }
    for (int i = 0; i < (max(lenp, lenu, 1)); i++) {
        sum = sum + d[i];
    }
    if (count != 0) {
        aver = sum / count; //平均距离，可用于与阈值比较
    }
    //释放
    for (int i = 0; i < lenp; i++) {
        free(matrix[i]);
        matrix[i] = NULL;
    }
    free(matrix);
    matrix = NULL;

    for (int i = 0; i < (n + 2); i++) {
        free(path[i]);
        path[i] = NULL;
    }
    free(path);
    path = NULL;
    return aver;
}

int main() {
	int distance = 0;
	distance = findpath(creatmatrix(point4, pointout),point4,point5);
	printf("%d", distance);



	return 0;
}